# 문자열 압축 💬
> 프로그래머스 레벨2   
> https://programmers.co.kr/learn/courses/30/lessons/60057   

<br>

## 문제 조건
- 문자열 s가 주어진다.(1 <= s <= 1000)
- 정해진 규칙에 따라 문자열을 압축한다.
- 압축한 문자열 중 길이가 가장 짧은 것의 길이를 반환한다.

<br>

## 문제 아이디어
&nbsp; 입력으로 주어지는 문자열이 1000이하이기 때문에 **완전탐색**이 가능하다. 최대로 압축할 수 있는 단위는 N/2이다. 1부터 **N/2**까지의 모든 수를 단위로 하여 문자열을 압축하는 방법을 모두 확인하고 이 중 가장 짧게 압축되는 길이를 출력한다.   
&nbsp; 문자열 압축방식에 대한 이해가 필요한데, 문자열은 제일 앞부터 정해진 길이만큼만 잘라야한다. (x)(abc)(abc) 이렇게는 자를 수 없다.

&nbsp; 코드를 작성할때 팁은 파이썬의 문자열(배열)을 다룰 때는 **인덱스 범위**가 나가는 것을 따로 처리하지 않아도 된다는 것이다. 예를들어 s='abc'가 있을때, s[2:5]는 'c'다. 따로 에러가 나지않는다. 

&nbsp; 아이디어 자체는 어렵지 않은 전형적인 구현문제였다. 나의 경우에는 주어진 문자열에서 **단위길이 만큼씩 이동**하며, **현재 구역의 문자열**이 **앞의 구역의 문자열과 동일한지**를 확인한다. 동일하다면 cnt라는 반복 횟수를 증가시킨다. 동일하지 않다면, 반복횟수와 같이 현재 구역의 문자열을 붙여준다.

<br>

## 예시
```
xaaaaaaaaaaaa
```
- 주어진 문자열을 1로 압축하면 x12a이다.   
- 2로 압축하면 xa**5aa**a이다.  
    -> **xa**는 압축될 수 없어 그대로 작성하였고 이후 **aa**가 5번 반복된다. **맨 마지막 a**역시 압축될 수 없어 그대로 작성되었다.   
- 3로 압축하면 xaa**3aaa**a이다   
    -> 맨처음 xaa와 맨 마지막 a는 압축될 수 없어 그대로 작성하였고 중간 aaa는 3번 반복되었다.
- 4로 압축하면 xaaa**2aaaa**a이다.
- 5로 압축하면 xaaaaaaaaaaaa로 압축되지 않는다.
- 6로 압축하면 xaaaaaaaaaaaa로 압축되지 않는다.

이때 가장 짧은 문자열은 x12a로 출력값은 4가 된다.

<br>

## 코드
```python
def solution(s):
    answer = len(s)
    for step in range(1, len(s)//2 + 1):
        k = 0
        cnt = 1
        result = ''
        while k <= len(s):
            # 지금 문자열이 아직 더 반복될 예정이라면
            if s[k:k+step] == s[k+step : k + 2*step]:
                cnt += 1
            # 지금 문자열이 앞으로 반복되진 않는다면
            else:
                # 반복되었다면, 그 문자열 앞에 반복 횟수가 붙는다
                if cnt > 1:
                    result += str(cnt) + s[k:k+step]
                    cnt = 1
                # 반복되지 않았었다면, 반복 횟수가 붙지 않는다
                else:
                    result += s[k:k+step]
            k = k + step
        
        answer = min(answer, len(result))
    return answer
```